---
title: "バレないように外部関数を呼び出す方法"
emoji: "🥳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [CTF, C]
published: false
---

`nm`で検出されることなく外部関数を呼び出すために行ったことをまとめた記事です（何に使用するかは自己責任でお願いします）
今回は`system`関数について書きます（他に対しても同様の方法で書けます）

# 導入

皆さんは[nmコマンド](https://nxmnpg.lemoda.net/ja/1/nm)をご存知でしょうか？
このコマンドを使用すると、指定したオブジェクトファイル（指定しない場合は`a.out`）で使用されているシンボルテーブルを見ることが出来ます（詳しいnmについてはmanを読んでください）。
これを見るとそのオブジェクトファイルや実行ファイルで使用している外部関数を確認することが出来るのですが、それにバレずに外部関数を呼び出してみよう！！という記事です

今回は簡易化のために、以下の様な問題設定にします
```c:問題設定
実装言語: C
使用可能関数: freeのみ

shellを実装してください。ただし、以下の様なフォーマットで実行されます（第二引数の文字列を処理）
$ a.out "ls -la | grep test | wc -l"
> 3
```

# 行うこと（回答のみ知りたい方向け）

::: message
前提: clang でコンパイル
:::

**offsetの取得:** 以下のコマンドをターミナル上で実行し[readelf](https://nxmnpg.lemoda.net/ja/1/readelf)の出力から`offset`求める


```c: readelfコマンド
$ readelf -s /lib/x86_64-linux-gnu/libc.so.6
// readelfの引数は以下などで取得できる
// $ ldd printf
```


**実行:** libcのアドレスをリークさせて、求めたoffsetから実行したい関数にgotアドレスを使用して直接アクセスする


```c: system.c
#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// 以下の値は、上記のファイルで使用したreadelfコマンドを手元で実行して出てきたoffsetの一覧から
// grepなどをして system, free の値を入れる。16進数なので頭に0xを付ける
#define SYSTEM_OFFSET 0x50d70
#define FREE_OFFSET 0xa53e0

int main(int argc, char **argv) {
  if (argc != 2) {
    return 1;
  }

  free(NULL);
  uintptr_t libc_base = 
    *(uintptr_t *)((void *)free + 6 + *(int *)((void *)free + 2)) - FREE_OFFSET;
  int (*hacked_system)(const char *) = (void *)(libc_base + SYSTEM_OFFSET);

  return hacked_system(argv[1]);
}

```


# そもそも何をしたいのか

上記を読んでも、CTFなどをやったことない方はさっぱりわからないと思うので、そもそも何をしたいのかから説明していきます

そもそも、行いたいことの目的としては **使用可能関数以外も使いたい** ということです
課題には`使用可能関数: freeのみ`と書かれており、普通は実装出来ません。

しかし、これ以外の関数を使えた場合にこの課題の内容を実装しようと思った場合はどのようになるでしょう？
例えば今回の課題だと`shell`を実装してくださいという課題であり、`fork`や`execve`などを使用して同様のことを行うプログラムを作ることも出来ますが、実際の`shell`を呼び出すことができれば、1行で終わる話です。

では、どうやってfreeのみを使用しているのか確かめているのでしょう。
幾つか確認する方法はあるのですが、今回は[nm](https://nxmnpg.lemoda.net/ja/1/nm)を使用していると仮定して、そこにバレない様に外部関数を呼び出します
他の方法の一つに[ptrace](https://nxmnpg.lemoda.net/ja/2/ptrace)があります。ptraceを使用している場合はあるプロセスがその他のプロセスで実行されているプログラムを追って、どのシステムが呼ばれたか、どのメモリやレジスタの値を読み取ったのかなどを見れるので、どう頑張っても使用可能関数以外を呼んだらバレてしまうでしょう。
しかし、nmコマンドの場合は話が違います。`nm -D a.out`などで、実行ファイルがどのような共有ライブラリを呼び出しているのかがわかりますが、そこにさえ引っ掛からなければバレずに呼び出すことができる可能性があります

> なぜlibcのプログラムは静的リンクではなく、動的リンクをしている？？
>
> これはメモリ効率の観点と保守性の観点の二つがあり、メモリ効率の観点では、例えば`printf`などの関数を複数のファイルで使用している時に、それぞれのすべてがメモリ上にロードされて、RAMやディスクを無駄遣いしてしまう可能性があるため。
> 保守性の観点では、例えば、`printf`に致命的なバグが見つかったとして、静的リンクの場合は`printf`を使用しているすべての関数を再度コンパイルしなくてはならなくなるが、動的リンクの場合は実行時に解決するので、OSのアップデートをするだけで、システム上のすべてのプログラムが自動的に修正済みの`printf`を使用するようになるため。

では、どうやったらlibcの関数をバレずに呼び出せるのでしょうか？

その前に、そもそもnmコマンドとは何をしているのでしょうか？どうやって外部関数を読んだことをわかるのでしょうか？

# nmとは

`nm`とはシンボルを見ているだけです。オプションの`-D`は`--dynamic`と同じで、動的シンボルテーブルの一覧を出力しているだけです。
そもそも動的シンボルテーブルとは、という話にもなるので、順序立てて見ていきます

私たちが`printf`などの外部関数を使用したファイルをコンパイルして（clang main.c -o my_program）実行ファイルを作成するときにリンカーが走ります。リンク時にリンカーは`main.c`では`printf`を読んでいるんだな、と認識します。
その際に、`printf`は共有ライブラリにあるため、`printf`のコードをファイルにコピーせず、その代わりに`my_program`の動的シンボルテーブルというリストに`U printf`ということを書き込みます。（`U:type printf:function`）
その後`nm -D my_program`とすると、動的シンボルテーブルにある`U`というシンボルを見て表示しています。

> 主なシンボル
> T (Text section): そのファイル内にコード（実体）が存在する関数
> D (Data section): そのファイル内に実体があるグローバル変数
> U (Undefined): このシンボル（関数）を呼び出すけれど、実体はこのファイルの中に存在しない関数
> [man nm](https://nxmnpg.lemoda.net/ja/1/nm)

なので、それらを掻い潜るためには実際にコード内に`shell`を実装しないといけないのですが、他にも方法があります

それが、libcの中の[system](https://linuxjm.sourceforge.io/html/LDP_man-pages/man3/system.3.html)が置かれているアドレスを実行時に計算して、直接指定して呼び出してあげるという方法です
これはリンク時ではなく実行時に動的に計算するので、リンカーが`sytem`を動的にリンクして解決しているわけではないです。そのため、静的解析ツールであるnmコマンドにバレずに実際の`system`を呼び出して実行できるのです！🎊

# 欲しい情報
何となくやりたいことが掴めたと思うので今一度確認し、欲しい情報を考えていきます。

やりたいこととしては、実際の`libc`に置かれている`sytem`のアドレスを知りたい、ということです。それさえ知れれば、実際の`system`を呼び出して終了です。（`sytem`のやり方さえわかれば`sytem`以外の場所もわかるので、全ての`libc`にある関数を容易に使用することができます）

ではどうやったら`system`の場所を知れるのでしょうか

まずは[libc](https://manpages.ubuntu.com/manpages/jammy/ja/man7/libc.7.html)(今回は`glibc`)がどこに置かれているのか、どのような構造になっているのかを見ていきます

`glibc`とはLinuxに必要な標準関数(`malloc`, `printf`, `free`, `system`, ...)を詰め込んだ大きな辞書のような物で、各関数は辞書のページのような物です。

`glibc`は実行時にメモリ上にロードされるのですが、毎回実行時にランダムに配置されます。しかし、`glibc`の標準関数の並び順などは常に一定で、先頭のアドレスからどのくらい離れているのかというのを決める、オフセット（相対アドレス）というのものがあり、それはマシン毎に異なります（実行時には変わらない）。

> ASLR（アドレス空間配置のランダム化）:
>
> プログラムを実行するたび、OSはASLRというセキュリティ機能によって、`glibc`をメモリのランダムな場所に配置します

なので、**glibcの先頭のアドレス（base address）** と **systemのオフセット（先頭のアドレスからsystem関数のアドレスまでの距離）**さえわかれば`system`のアドレスを特定することができます

```c

OSが実行時に決定するランダムなベースアドレス
(例: 0xAAAABBBB0000)
       |
       |
       V
+----------------------------------------------------+
| glibc.so.6 (Loaded Entity in Memory)               | <--- +--(Base Address)
+====================================================+      |      |
|                                                    |      |      |
| ... (Countless other functions) ...                | (system's offset)
|                                                    |      |      |
| +--------------------------------------+           |      |      |
| |                                      |           |      |      |
| |         system() code                |           | <----+      |
| |       (Target Function)              |           |             |
| |                                      |           |             |
| +--------------------------------------+           |             |
|                                                    |             |
| ... (Countless other functions) ...                |      (free's offset)
|                                                    |             |
| +---------------------------------------+          |             |
| |                                       |          |             |
| |         free() code                   |          |             |
| |       (Allowed Function)              |          | <-----------+
| |                                       |          |
| +---------------------------------------+          |
|                                                    |
| ... (Countless other functions) ...                |
|                                                    |
+----------------------------------------------------+
                                                                   
glibcの先頭から関数までの距離は、ベースアドレスがどこであれ常に一定
```


# どうやって求めるか

では、`glibc`の先頭のアドレスと`system`のオフセットをどうやって求めるのかを見ていきましょう

オフセットは[readelf](https://nxmnpg.lemoda.net/ja/1/readelf)というコマンドを使用すると、そのマシンで使用されている`glibc`のオフセットを知ることができます

```txt:オフセットを知るためのコマンド
readelf -s /lib/x86_64-linux-gnu/libc.so.6
```

これは何をしているかというと、詳しく知りたい方はreadelfコマンドのmanを読んでいただければいいのですが、`ELFファイル`(Executable and Linkable Format)の情報の中で必要な情報をオプションで抜き取れます、というものです。`ELF`とはLinuxなどで広く使われている実行ファイルやオブジェクトファイルのためのフォーマットです。
`-s`オプションで、[シンボルテーブルの情報](https://docs.oracle.com/cd/E19253-01/819-0391/chapter6-79797/index.html#:~:text=%E5%86%8D%E9%85%8D%E7%BD%AE%E5%8F%AF%E8%83%BD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A7%E3%81%AF%E3%80%81st_value%20%E3%81%AF%E5%AE%9A%E7%BE%A9%E3%81%95%E3%82%8C%E3%81%9F%E3%82%B7%E3%83%B3%E3%83%9C%E3%83%AB%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E3%82%BB%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%AA%E3%83%95%E3%82%BB%E3%83%83%E3%83%88%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%BE%E3%81%99%E3%80%82st_value%20%E3%81%AF%E3%80%81st_shndx%20%E3%81%8C%E8%AD%98%E5%88%A5%E3%81%99%E3%82%8B%E3%82%BB%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%85%88%E9%A0%AD%E3%81%8B%E3%82%89%E3%81%AE%E3%82%AA%E3%83%95%E3%82%BB%E3%83%83%E3%83%88%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82)を抜き出してくることができます。ここにはオフセット（glibcの先頭からどれだけ離れているか）が入っているのでここを見れれば実行環境のオフセットを確認することができます

`readelf -s`でどこのシンボルを見るのかを引数で指定するのですが、そこには`glibc`のファイルパスを入れたいです。それはどうやって確認するのでしょうか？

[lddコマンド](https://linuxjm.sourceforge.io/html/LDP_man-pages/man1/ldd.1.html)というものをここでは使用しましょう。
このコマンドを実行すると、引数で与えられた対象ファイルの依存関係をlistにして表示してくれます。なので`ldd /bin/printf`など（`ldd /bin/ls`や`ldd a.out`など共有ライブラリを使用しているものならば何でも良い）をすると依存関係が出てきます
そうすると以下のような出力になると思います
```c:
$ ldd /bin/printf
        linux-vdso.so.1 (0x0000ffff9410f000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x0000ffff93f00000)
        /lib/ld-linux-x86-64.so.1 (0x0000ffff940d6000)
````

ここにある`libc.so.6`というものが、通常は glibc ライブラリがある場所を指すシンボリックリンクなので、そこの先にある`/lib/x86_64-linux-gnu/libc.so.6`が実際のglibcのファイルパスです。ここの`(0x0000ffff93f00000)`がglibcのbaseアドレスなので、これを使用したいのですが、ASLRで実行毎にランダムに置かれるので出来ません、、、😭

ですがこれで、オフセットの情報は整いました！

```c:
readelf -s /lib/x86_64-linux-gnu/libc.so.6
```

上記のコマンドを実行すればglibcのファイルパスのオフセットの一覧を出力することが出来るので、それを`grep`などすれば`system`のオフセットを知ることができます！

```shell:
$ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
  1015: 0000000000050d70    40 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.17
```

これの`000000000006d9e0`ここの値がオフセットです。16進数なので使用するときは`0x6d9e0`などとして使用します

> ついでにですが、以下のような出力形式になっています
>
> ```shell
> readelf -s /lib/x86_64-linux-gnu/libc.so.6 | head -3
> 
> Symbol table '.dynsym' contains 2940 entries:
>    Num:    Value          Size Type    Bind   Vis      Ndx Name
> ```

あとはベースアドレスを求めるだけです!

# ベースアドレスを求めよう！

ベースアドレスはどうやって求められうのでしょう？
考えることとしては、唯一`free`が使えることです。freeを使えるということは、free関数のアドレスが実行時には分かっていて、実行してくれるということです。
ここで先ほどの図に戻ってみましょう

```c

OSが実行時に決定するランダムなベースアドレス
(例: 0xAAAABBBB0000)
       |
       |
       V
+----------------------------------------------------+
| glibc.so.6 (Loaded Entity in Memory)               | <--- +--(Base Address)
+====================================================+      |      |
|                                                    |      |      |
| ... (Countless other functions) ...                | (system's offset)
|                                                    |      |      |
| +--------------------------------------+           |      |      |
| |                                      |           |      |      |
| |         system() code                |           | <----+      |
| |       (Target Function)              |           |             |
| |                                      |           |             |
| +--------------------------------------+           |             |
|                                                    |             |
| ... (Countless other functions) ...                |      (free's offset)
|                                                    |             |
| +---------------------------------------+          |             |
| |                                       |          |             |
| |         free() code                   |          |             |
| |       (Allowed Function)              |          | <-----------+
| |                                       |          |
| +---------------------------------------+          |
|                                                    |
| ... (Countless other functions) ...                |
|                                                    |
+----------------------------------------------------+
                                                                   
glibcの先頭から関数までの距離は、ベースアドレスがどこであれ常に一定
```

これを見るとベースアドレスにfreeのオフセットを足したらfreeの実アドレスになります。

つまり、freeのアドレスからfreeオフセットを引くとベースアドレスが取得できます！
freeのオフセットは先ほどの`readelf`で分かっているので、あとはfreeの実アドレスさえ分かれば完了です

ではfreeの実アドレスはどうやったら分かるのでしょうか？

それを分かるには、ライブラリ関数のアドレス解決の仕組みがわかる必要があります
詳しくは[他の方の記事](https://kashiwaba-yuki.com/linux-got-plt)等を読んで頂ければと思うので、今回は簡単にまとめてみます

実行ファイルを見てみてもfreeの実アドレスは書いていません。しかし、実行ファイルには色々な重要な情報が詰まっています。

Linuxの実行ファイルはELF([Executable and Linkable Format](https://ja.wikipedia.org/wiki/Executable_and_Linkable_Format]))という形式になっています。そもそもELFファイルとはどの様なものなのでしょうか。
詳しく知りたい方には[他の方の記事](https://qiita.com/ktamido/items/4c04175cfeb90a0dd6f0)を読んで頂きたいのですが、ELFファイルには様々なセクションというものがあります。セクションは役割ごとで区切られており、これがあることによりセクションごとに権限の設定などを行えて安全になります。主なセクションだとテキストセクション（機械語のコード）やデータセクション（初期値のあるグローバル変数や静的変数）などがあり、今回重要なのがPLTセクションとGOTセクションです。
では、それぞれについて見ていきましょう

Linuxでは、プログラム起動時にすべての共有ライブラリ関数のアドレスを解決するのではなく、最初に関数が呼び出された瞬間にPLT(Procedure Linkage Table)とGOT(Global Offet Table)という仕組みを使ってアドレスを解決します。


外部ライブラリ（libcなど）の関数を使用するとき、Linuxでは遅延バインディング（Lazy Binding）という仕組みを使っています。
遅延バインディングとは、必要になった時にアドレスを解決する、というものです。通常はプログラムの起動時にライブラリ関数をリンクします（メモリ上のどこかに呼び出される）。しかし、これら全てのアドレスを解決していると、起動が遅くなったり、一度も呼ばれない関数のアドレスまで調べることになり無駄が多いです。そこで、Linuxでは関数が最初に呼び出された時に初めてアドレスを調べる、という方針をとっています。

この仕組みを実現するために、PLTとGOTがそれぞれ使用されています

- PLT (Procedure Linkage Table)
  これは関数の呼び出し窓口のようなものです。
  実態はプログラム内の`.plt`セクションにある命令コードであり、自分たちの書いたコードは直接ライブラリを呼び出すのではなく、pltセクションを呼び出します（今回だとfree@plt）
  そしてPLTセクションがGOTセクションを呼び出しています

- GOT (Global Offset Table)
  これはキャッシュとほぼ同義です。
  プログラム内の`.got`（もしくは`.got.plt`）セクションにあるデータ領域で、実際のアドレスが書き込まれます

ではfreeを呼び出した時の流れを追ってみましょう

### freeの流れ
- 1回目の呼び出し

プログラムが初めてfree()を呼んだ時
- Call: 自分の書いたコードが`free@plt`を呼び出します
- Jump to GOT: PLTはまず、GOTの書いてあるアドレスへアクセスします
  - しかしGOTには初期値として、この命令の次の命令のアドレスが入っており、GOTへジャンプした直後にPLTの直後の行に戻ってきます
- Prepare: PLTはfreeをスタックに詰みます（これが順次リゾルバによって解決される）
- Resolve: 動的リンカがメモリ上のlibcのアドレスを探してfreeの実アドレスを見つけます
  - リンカがメモリ上にlibcを配置するのでベースアドレスは既に知っており、そこからシンボルテーブルを使用してアドレスを解決する
- Update GOT: 見つけた実アドレスをGOTに上書き保存します
- Execute: 実アドレスへ飛んで、freeを実行します

- 2回目の呼び出し

プログラムが再びfree()を呼んだ時
- Call: 自分の書いたコードが`free@plt`を呼び出す
- Jump to GOT: PLTがGOTの書いてあるアドレスへジャンプします
- Direct Jump: 既にGOTには前回の処理で実アドレスが書き込まれています
- Execute: 動的リンカを一切通さず、直接`libc`内の`free`関数へ飛んで実行されます



```c
$ objdump -d ./a.out

./a.out:     file format elf64-x86-64


Disassembly of section .init:

0000000000401000 <_init>:
  401000:       f3 0f 1e fa             endbr64
  401004:       48 83 ec 08             sub    $0x8,%rsp
  401008:       48 8b 05 e9 2f 00 00    mov    0x2fe9(%rip),%rax        # 403ff8 <__gmon_start__@Base>
  40100f:       48 85 c0                test   %rax,%rax
  401012:       74 02                   je     401016 <_init+0x16>
  401014:       ff d0                   call   *%rax
  401016:       48 83 c4 08             add    $0x8,%rsp
  40101a:       c3                      ret

Disassembly of section .plt:

0000000000401020 <free@plt-0x10>:
  401020:       ff 35 e2 2f 00 00       push   0x2fe2(%rip)        # 404008 <_GLOBAL_OFFSET_TABLE_+0x8>
  401026:       ff 25 e4 2f 00 00       jmp    *0x2fe4(%rip)        # 404010 <_GLOBAL_OFFSET_TABLE_+0x10>
  40102c:       0f 1f 40 00             nopl   0x0(%rax)

0000000000401030 <free@plt>:
  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <free@GLIBC_2.2.5>
  401036:       68 00 00 00 00          push   $0x0
  40103b:       e9 e0 ff ff ff          jmp    401020 <_init+0x20>

Disassembly of section .text:

0000000000401040 <_start>:
```





























# おまけ

オフセットを求めるにはローカルで`readelf`などを使えばいいのですが、自分の環境ではない環境のオフセットを求めたい時に
