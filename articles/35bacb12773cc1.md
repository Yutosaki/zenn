---
title: "バレないように外部関数を呼び出す方法"
emoji: "🥳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [CTF, C]
published: false
---

`nm`で検出されることなく外部関数を呼び出すために行ったことをまとめた記事です（何に使用するかは自己責任でお願いします）
今回は`system`関数について書きます（他に対しても同様の方法で書けます）
> [man system](https://linuxjm.sourceforge.io/html/LDP_man-pages/man3/system.3.html)

# 導入

皆さんは[nmコマンド](https://nxmnpg.lemoda.net/ja/1/nm)をご存知でしょうか？
このコマンドを使用すると、指定したオブジェクトファイル（指定しない場合は`a.out`）で使用されているシンボルテーブルを見ることが出来ます（詳しいnmについてはmanを読んでください）。
これを見るとそのオブジェクトファイルや実行ファイルで使用している外部関数を確認することが出来るのですが、それにバレずに外部関数を呼び出してみよう！！という記事です

今回は簡易化のために、以下の様な問題設定にします
```c:問題設定
実装言語: C
使用可能関数: freeのみ

shellを実装してください。ただし、以下の様なフォーマットで実行されます（第二引数の文字列を処理）
$ a.out "ls -la | grep test | wc -l"
> 3
```

# 行うこと（回答のみ知りたい方向け）

::: message
**前提環境 / コンパイル条件:**
* **Arch:** x86_64 (amd64) Linux
* **Security:** Partial RELRO (GOTへの書き込みが許可されており、Lazy Binding有効)
   * ※ Full RELROの場合はLazy Bindingが起きないため解説の挙動と異なります。コード自体は動くことが多いです
* **Compiler:** PLTスタブが `jmp *offset(%rip)` (ff 25 ...) で始まっていること
    * ※ `endbr64` が付与される環境ではオフセットの調整が必要です

:::details オプションを付ける場合の指定方法方法
-z lazy: 遅延バインディングを強制（Partial RELRO）
-fno-cf-protection: endbr64 (Intel CET) を無効化して機械語を単純にする

clang -z lazy -fno-cf-protection main.c
:::

:::
**offsetの取得:** 以下のコマンドをターミナル上で実行し[readelf](https://nxmnpg.lemoda.net/ja/1/readelf)の出力から`offset`求める


```c: readelfコマンド
$ readelf -s /lib/x86_64-linux-gnu/libc.so.6
// readelfの引数は以下などで取得できる
// $ ldd printf
```


**実行:** libcのアドレスをリークさせて、求めたoffsetから実行したい関数にgotアドレスを使用して直接アクセスする


```c: system.c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// 以下の値は、上記のファイルで使用したreadelfコマンドを手元で実行して出てきたoffsetの一覧から
// grepなどをして system, free の値を入れる。16進数なので頭に0xを付ける
#define SYSTEM_OFFSET 0x50d70
#define FREE_OFFSET 0xa53e0

int main(int argc, char **argv) {
  if (argc != 2) {
    return 1;
  }

  free(NULL);
  uintptr_t libc_base = 
    *(uintptr_t *)((void *)free + 6 + *(int *)((void *)free + 2)) - FREE_OFFSET;
  int (*hacked_system)(const char *) = (void *)(libc_base + SYSTEM_OFFSET);

  return hacked_system(argv[1]);
}
```


# そもそも何をしたいのか

上記を読んでも、CTFなどをやったことない方はさっぱりわからないと思うので、そもそも何をしたいのかから説明していきます

そもそも、行いたいことの目的としては **使用可能関数以外も使いたい** ということです
課題には`使用可能関数: freeのみ`と書かれており、普通は実装出来ません。

しかし、これ以外の関数を使えた場合にこの課題の内容を実装しようと思った場合はどのようになるでしょう？
例えば今回の課題だと`shell`を実装してくださいという課題であり、`fork`や`execve`などを使用して同様のことを行うプログラムを作ることも出来ますが、実際の`shell`を呼び出すことができれば、1行で終わる話です。

では、どうやってfreeのみを使用しているのか確かめているのでしょう。
幾つか確認する方法はあるのですが、今回は[nm](https://nxmnpg.lemoda.net/ja/1/nm)を使用していると仮定して、そこにバレない様に外部関数を呼び出します
他の方法の一つに[strace](https://man7.org/linux/man-pages/man1/strace.1.html)があります。straceは動的解析ツールなので、あるプロセスがその他のプロセスで実行されているプログラムを追って、どのシステムが呼ばれたか、どのメモリやレジスタの値を読み取ったのかなどを見れるので、どう頑張っても使用可能関数以外を呼んだらバレてしまうでしょう。
しかし、nmコマンドのような静的解析ツールの場合は話が違います。`nm -D a.out`などで、実行ファイルがどのような共有ライブラリを呼び出しているのかがわかりますが、そこにさえ引っ掛からなければバレずに呼び出すことができる可能性があります

> なぜlibcのプログラムは静的リンクではなく、動的リンクをしている？？
>
> これはメモリ効率の観点と保守性の観点の二つがあり、メモリ効率の観点では、例えば`printf`などの関数を複数のファイルで使用している時に、それぞれのすべてがメモリ上にロードされて、RAMやディスクを無駄遣いしてしまう可能性があるため。
> 保守性の観点では、例えば、`printf`に致命的なバグが見つかったとして、静的リンクの場合は`printf`を使用しているすべての関数を再度コンパイルしなくてはならなくなるが、動的リンクの場合は実行時に解決するので、OSのアップデートをするだけで、システム上のすべてのプログラムが自動的に修正済みの`printf`を使用するようになるため。

では、どうやったらlibcの関数をバレずに呼び出せるのでしょうか？

その前に、そもそもnmコマンドとは何をしているのでしょうか？どうやって外部関数を読んだことをわかるのでしょうか？

# nmとは

`nm`とはシンボルを見ているだけです。オプションの`-D`は`--dynamic`と同じで、動的シンボルテーブルの一覧を出力しているだけです。
そもそも動的シンボルテーブルとは、という話にもなるので、順序立てて見ていきます

私たちが`printf`などの外部関数を使用したファイルをコンパイルして（clang main.c -o my_program）実行ファイルを作成するときにリンカーが走ります。リンク時にリンカーは`main.c`では`printf`を読んでいるんだな、と認識します。
その際に、`printf`は共有ライブラリにあるため、`printf`のコードをファイルにコピーせず、その代わりに`my_program`の動的シンボルテーブルというリストに`U printf`ということを書き込みます。（`U:type printf:function`）
その後`nm -D my_program`とすると、動的シンボルテーブルにある`U`というシンボルを見て表示しています。

> 主なシンボル
> T (Text section): そのファイル内にコード（実体）が存在する関数
> D (Data section): そのファイル内に実体があるグローバル変数
> U (Undefined): このシンボル（関数）を呼び出すけれど、実体はこのファイルの中に存在しない関数
> [man nm](https://nxmnpg.lemoda.net/ja/1/nm)

なので、それらを掻い潜るためには実際にコード内に`shell`を実装しないといけないのですが、他にも方法があります

それが、libcの中の[system](https://linuxjm.sourceforge.io/html/LDP_man-pages/man3/system.3.html)が置かれているアドレスを実行時に計算して、直接指定して呼び出してあげるという方法です
これはリンク時ではなく実行時に動的に計算するので、リンカーが`system`を動的にリンクして解決しているわけではないです。そのため、静的解析ツールであるnmコマンドにバレずに実際の`system`を呼び出して実行できるのです！🎊

# 欲しい情報
何となくやりたいことが掴めたと思うので今一度確認し、欲しい情報を考えていきます。

やりたいこととしては、実際の`libc`に置かれている`system`のアドレスを知りたい、ということです。それさえ知れれば、実際の`system`を呼び出して終了です。（`sytem`のやり方さえわかれば`sytem`以外の場所もわかるので、全ての`libc`にある関数を容易に使用することができます）

ではどうやったら`system`の場所を知れるのでしょうか

まずは[libc](https://manpages.ubuntu.com/manpages/jammy/ja/man7/libc.7.html)(今回は`glibc`)がどこに置かれているのか、どのような構造になっているのかを見ていきます

`glibc`とはLinuxに必要な標準関数(`malloc`, `printf`, `free`, `system`, ...)を詰め込んだ大きな辞書のような物で、各関数は辞書のページのような物です。

`glibc`は実行時にメモリ上にロードされるのですが、毎回実行時にランダムに配置されます。しかし、`glibc`の標準関数の並び順などは常に一定で、先頭のアドレスからどのくらい離れているのかというのを決める、オフセット（相対アドレス）というのものがあり、それはマシン毎に異なります（実行時には変わらない）。

> ASLR（アドレス空間配置のランダム化）:
>
> プログラムを実行するたび、OSはASLRというセキュリティ機能によって、`glibc`をメモリのランダムな場所に配置します

なので、**glibcの先頭のアドレス（base address）** と **systemのオフセット（先頭のアドレスからsystem関数のアドレスまでの距離）**さえわかれば`system`のアドレスを特定することができます

```c

OSが実行時に決定するランダムなベースアドレス
(例: 0xAAAABBBB0000)
       |
       |
       V
+----------------------------------------------------+
| glibc.so.6 (Loaded Entity in Memory)               | <--- +--(Base Address)
+====================================================+      |      |
|                                                    |      |      |
| ... (Countless other functions) ...                | (system's offset)
|                                                    |      |      |
| +--------------------------------------+           |      |      |
| |                                      |           |      |      |
| |         system() code                |           | <----+      |
| |       (Target Function)              |           |             |
| |                                      |           |             |
| +--------------------------------------+           |             |
|                                                    |             |
| ... (Countless other functions) ...                |      (free's offset)
|                                                    |             |
| +---------------------------------------+          |             |
| |                                       |          |             |
| |         free() code                   |          |             |
| |       (Allowed Function)              |          | <-----------+
| |                                       |          |
| +---------------------------------------+          |
|                                                    |
| ... (Countless other functions) ...                |
|                                                    |
+----------------------------------------------------+
                                                                   
glibcの先頭から関数までの距離は、ベースアドレスがどこであれ常に一定
```


# どうやって求めるか

では、`glibc`の先頭のアドレスと`system`のオフセットをどうやって求めるのかを見ていきましょう

オフセットは[readelf](https://nxmnpg.lemoda.net/ja/1/readelf)というコマンドを使用すると、そのマシンで使用されている`glibc`のオフセットを知ることができます

```txt:オフセットを知るためのコマンド
readelf -s /lib/x86_64-linux-gnu/libc.so.6
```

これは何をしているかというと、詳しく知りたい方はreadelfコマンドのmanを読んでいただければいいのですが、`ELFファイル`(Executable and Linkable Format)の情報の中で必要な情報をオプションで抜き取れます、というものです。`ELF`とはLinuxなどで広く使われている実行ファイルやオブジェクトファイルのためのフォーマットです。
`-s`オプションで、[シンボルテーブルの情報](https://docs.oracle.com/cd/E19253-01/819-0391/chapter6-79797/index.html#:~:text=%E5%86%8D%E9%85%8D%E7%BD%AE%E5%8F%AF%E8%83%BD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A7%E3%81%AF%E3%80%81st_value%20%E3%81%AF%E5%AE%9A%E7%BE%A9%E3%81%95%E3%82%8C%E3%81%9F%E3%82%B7%E3%83%B3%E3%83%9C%E3%83%AB%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E3%82%BB%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%AA%E3%83%95%E3%82%BB%E3%83%83%E3%83%88%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%97%E3%81%BE%E3%81%99%E3%80%82st_value%20%E3%81%AF%E3%80%81st_shndx%20%E3%81%8C%E8%AD%98%E5%88%A5%E3%81%99%E3%82%8B%E3%82%BB%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%85%88%E9%A0%AD%E3%81%8B%E3%82%89%E3%81%AE%E3%82%AA%E3%83%95%E3%82%BB%E3%83%83%E3%83%88%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82)を抜き出してくることができます。ここにはオフセット（glibcの先頭からどれだけ離れているか）が入っているのでここを見れれば実行環境のオフセットを確認することができます

`readelf -s`でどこのシンボルを見るのかを引数で指定するのですが、そこには`glibc`のファイルパスを入れたいです。それはどうやって確認するのでしょうか？

[lddコマンド](https://linuxjm.sourceforge.io/html/LDP_man-pages/man1/ldd.1.html)というものをここでは使用しましょう。
このコマンドを実行すると、引数で与えられた対象ファイルの依存関係をlistにして表示してくれます。なので`ldd /bin/printf`など（`ldd /bin/ls`や`ldd a.out`など共有ライブラリを使用しているものならば何でも良い）をすると依存関係が出てきます
そうすると以下のような出力になると思います
```c:
$ ldd /bin/printf
        linux-vdso.so.1 (0x0000ffff9410f000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x0000ffff93f00000)
        /lib/ld-linux-x86-64.so.1 (0x0000ffff940d6000)
````

ここにある`libc.so.6`というものが、通常は glibc ライブラリがある場所を指すシンボリックリンクなので、そこの先にある`/lib/x86_64-linux-gnu/libc.so.6`が実際のglibcのファイルパスです。ここの`(0x0000ffff93f00000)`がglibcのbaseアドレスなので、これを使用したいのですが、ASLRで実行毎にランダムに置かれるので出来ません、、、😭

ですがこれで、オフセットの情報は整いました！

```c:
readelf -s /lib/x86_64-linux-gnu/libc.so.6
```

上記のコマンドを実行すればglibcのファイルパスのオフセットの一覧を出力することが出来るので、それを`grep`などすれば`system`のオフセットを知ることができます！

```shell:
$ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
  1015: 0000000000050d70    40 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.17
```

これの`000000000006d9e0`ここの値がオフセットです。16進数なので使用するときは`0x6d9e0`などとして使用します

> ついでにですが、以下のような出力形式になっています
>
> ```shell
> readelf -s /lib/x86_64-linux-gnu/libc.so.6 | head -3
> 
> Symbol table '.dynsym' contains 2940 entries:
>    Num:    Value          Size Type    Bind   Vis      Ndx Name
> ```

あとはベースアドレスを求めるだけです!

# ベースアドレスを求めよう！

ベースアドレスはどうやって求められうのでしょう？
考えることとしては、唯一`free`が使えることです。freeを使えるということは、free関数のアドレスが実行時には分かっていて、実行してくれるということです。
ここで先ほどの図に戻ってみましょう

```c

OSが実行時に決定するランダムなベースアドレス
(例: 0xAAAABBBB0000)
       |
       |
       V
+----------------------------------------------------+
| glibc.so.6 (Loaded Entity in Memory)               | <--- +--(Base Address)
+====================================================+      |      |
|                                                    |      |      |
| ... (Countless other functions) ...                | (system's offset)
|                                                    |      |      |
| +--------------------------------------+           |      |      |
| |                                      |           |      |      |
| |         system() code                |           | <----+      |
| |       (Target Function)              |           |             |
| |                                      |           |             |
| +--------------------------------------+           |             |
|                                                    |             |
| ... (Countless other functions) ...                |      (free's offset)
|                                                    |             |
| +---------------------------------------+          |             |
| |                                       |          |             |
| |         free() code                   |          |             |
| |       (Allowed Function)              |          | <-----------+
| |                                       |          |
| +---------------------------------------+          |
|                                                    |
| ... (Countless other functions) ...                |
|                                                    |
+----------------------------------------------------+
                                                                   
glibcの先頭から関数までの距離は、ベースアドレスがどこであれ常に一定
```

これを見るとベースアドレスにfreeのオフセットを足したらfreeの実アドレスになります。

つまり、freeのアドレスからfreeオフセットを引くとベースアドレスが取得できます！
freeのオフセットは先ほどの`readelf`で分かっているので、あとはfreeの実アドレスさえ分かれば完了です

ではfreeの実アドレスはどうやったら分かるのでしょうか？

それを分かるには、ライブラリ関数のアドレス解決の仕組みがわかる必要があります
詳しくは[他の方の記事](https://kashiwaba-yuki.com/linux-got-plt)等を読んで頂ければと思うので、今回は簡単にまとめてみます

実行ファイルを見てみてもfreeの実アドレスは書いていません。しかし、実行ファイルには色々な重要な情報が詰まっています。

Linuxの実行ファイルはELF([Executable and Linkable Format](https://ja.wikipedia.org/wiki/Executable_and_Linkable_Format]))という形式になっています。そもそもELFファイルとはどの様なものなのでしょうか。
詳しく知りたい方には[他の方の記事](https://qiita.com/ktamido/items/4c04175cfeb90a0dd6f0)を読んで頂きたいのですが、ELFファイルには様々なセクションというものがあります。セクションは役割ごとで区切られており、これがあることによりセクションごとに権限の設定などを行えて安全になります。主なセクションだとテキストセクション（機械語のコード）やデータセクション（初期値のあるグローバル変数や静的変数）などがあり、今回重要なのがPLTセクションとGOTセクションです。
では、それぞれについて見ていきましょう

Linuxでは、プログラム起動時にすべての共有ライブラリ関数のアドレスを解決するのではなく、最初に関数が呼び出された瞬間にPLT(Procedure Linkage Table)とGOT(Global Offet Table)という仕組みを使ってアドレスを解決します。


外部ライブラリ（libcなど）の関数を使用するとき、Linuxでは遅延バインディング（Lazy Binding）という仕組みを使っています。
遅延バインディングとは、必要になった時にアドレスを解決する、というものです。通常はプログラムの起動時にライブラリ関数をリンクします（メモリ上のどこかに呼び出される）。しかし、これら全てのアドレスを解決していると、起動が遅くなったり、一度も呼ばれない関数のアドレスまで調べることになり無駄が多いです。そこで、Linuxでは関数が最初に呼び出された時に初めてアドレスを調べる、という方針をとっています。

この仕組みを実現するために、PLTとGOTがそれぞれ使用されています

- PLT (Procedure Linkage Table)
  これは関数の呼び出し窓口のようなものです。
  実態はプログラム内の`.plt`セクションにある命令コードであり、自分たちの書いたコードは直接ライブラリを呼び出すのではなく、pltセクションを呼び出します（今回だとfree@plt）
  そしてPLTセクションがGOTセクションを呼び出しています

- GOT (Global Offset Table)
  これはキャッシュとほぼ同義です。
  プログラム内の`.got`（もしくは`.got.plt`）セクションにあるデータ領域で、実際のアドレスが書き込まれます
  8バイトのアドレスが縦に並んだ単純な配列です

ではfreeを呼び出した時の流れを追ってみましょう

#### freeの流れ
##### 1回目の呼び出し

プログラムが初めてfree()を呼んだ時
- Call: 自分の書いたコードが`free@plt`を呼び出します
- Jump to GOT: PLTはまず、GOTの書いてあるアドレスへアクセスします
  - しかしGOTには初期値として、この命令の次の命令のアドレスが入っており、GOTへジャンプした直後にPLTの直後の行に戻ってきます
- Prepare: PLTはfreeをスタックに積みます（これが順次リゾルバによって解決される）
- Resolve: 動的リンカがメモリ上のlibcのアドレスを探してfreeの実アドレスを見つけます
  - リンカがメモリ上にlibcを配置するのでベースアドレスは既に知っており、そこからシンボルテーブルを使用してアドレスを解決する
- Update GOT: 見つけた実アドレスをGOTに上書き保存します
- Execute: 実アドレスへ飛んで、freeを実行します


##### 2回目の呼び出し

プログラムが再びfree()を呼んだ時
- Call: 自分の書いたコードが`free@plt`を呼び出す
- Jump to GOT: PLTがGOTの書いてあるアドレスへジャンプします
- Direct Jump: 既にGOTには前回の処理で実アドレスが書き込まれています
- Execute: 動的リンカを一切通さず、直接`libc`内の`free`関数へ飛んで実行されます

では実際に[objdump](https://linuxjm.sourceforge.io/html/GNU_binutils/man1/objdump.1.html)をして、ELFファイルの中身を見ていきましょう


```c
$ objdump -d ./a.out

./a.out:     file format elf64-x86-64


Disassembly of section .init:
...
Disassembly of section .plt:

0000000000401020 <free@plt-0x10>:
  401020:       ff 35 e2 2f 00 00       push   0x2fe2(%rip)        # 404008 <_GLOBAL_OFFSET_TABLE_+0x8>
  401026:       ff 25 e4 2f 00 00       jmp    *0x2fe4(%rip)        # 404010 <_GLOBAL_OFFSET_TABLE_+0x10>
  40102c:       0f 1f 40 00             nopl   0x0(%rax)

0000000000401030 <free@plt>:
  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <free@GLIBC_2.2.5>
  401036:       68 00 00 00 00          push   $0x0
  40103b:       e9 e0 ff ff ff          jmp    401020 <_init+0x20>

Disassembly of section .text:

0000000000401040 <_start>:
...
```

上記の出力を見て欲しいのですが、下の`<free@plt>`が実際にfree()を呼んだ時に呼ばれるpltセクションです。そして上の`<free@plt-0x10>`が動的リンカに積まれたスタックの部分です。
最初に呼ばれる`<free@plt>`の中の`401036`というアドレスで`push $0x0`としていますが、ここで上の部分のリンカが解決するスタックに積まれ、積まれた瞬間に動的リンカがアドレスを解決しています

ではここで一度整理します

現在行いたいこととしては`free`の実アドレスを知りたいということです。これを知れれば、実アドレスからオフセットを引いてベースアドレスを求めることができ、好きなライブラリ関数を呼び出すことができます。
そして、外部関数を一度呼び出すと動的リンカが走り、GOTテーブルに`free`の実アドレスが入ります。あとはそこの値さえ分かれば良いです。

ここで`free`が何のアドレスを指しているかについて考えます
C言語で`free`という関数名を書くとそれは関数のアドレスを意味します。
特に動的リンクされている場合、これは`free@plt`の先頭アドレス(`0x401030`)を指しています。ここからGOTに飛んで、GOTの中にあるアドレスを見て`free`が実行されます

objdumpの結果に書かれている以下の行を見てみましょう

```shell
0000000000401030 <free@plt>:
  401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <free@GLIBC_2.2.5>
```

これは何かというと、`free`という関数を呼び出した時に実際に機械が行っている作業を人間がギリギリ読めるようなコードに直したものです(`objdump -d`: `Disassembly`)

ここの説明をすると、一番左にある数字(`401030`, `401036`)がメモリアドレスです。ここのメモリに来た時に、後にある命令を実行してください、というものです。そして、その命令の内容が`ff 25 e2 2f 00 00`というところで、バイト列の機械語です。慣れれば読めるのですが、筆者は慣れていないので`objdump`に`-d`オプションを付けて読めるようにしています。
`-d`オプションを付けてギリギリ人間の読める形に直したのがその右にある`jmp *0x2fe2(%rip)`というところで、実際のELFファイルには書いていないのですが、ここを読めば大抵の命令はわかります

ではここの機械語を見てきましょう
まず一番左の`401030`が`free`が呼ばれた時にアクセスされるアドレスです
そして何やらよくわからない数字列`ff 25 e2 2f 00 00`とあります。ここにある`ff 25`が`jmp`命令です。これは、その後ろにある値をオフセット（現在の位置からどれくらい離れているか）として、RIP(次の命令)から相対位置にあるアドレスの中身へ移動せよ、という命令です
そして、`e2 2f 00 00`がジャンプ先を計算するための数値（オフセット）です

これを計算すると`#`以降にある、`404018`という値になるのですが、次の命令のアドレス(`401036`)から`002fe2`足したアドレス（[リトルエンディアン](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3#:~:text=%E6%95%B0%E5%80%A4%E3%81%AE1%E7%95%AA%E5%B0%8F%E3%81%95%E3%81%84%E6%A1%811%E3%83%90%E3%82%A4%E3%83%88%E5%88%86%E3%82%92%E3%80%811%E7%95%AA%E5%B0%8F%E3%81%95%E3%81%84%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%81%AE%E8%A8%98%E6%86%B6%E8%A3%85%E7%BD%AE%E3%81%AB%E9%85%8D%E7%BD%AE%E3%81%97%E9%A0%86%E3%81%AB%E4%B8%A6%E3%81%B9%E3%82%8B%E8%A6%8F%E5%89%87%E3%82%92%E3%83%AA%E3%83%88%E3%83%AB%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3%E3%81%A8%E3%81%84%E3%81%86)のため）に`jmp`せよ、というのがこの行の命令です

ここが何のアドレスかというのは先ほどもお話ししたように、GOTテーブル中の`free`の実アドレスが入っているアドレスです。ここに次の命令が書かれており、一度`free`を呼び出すとこのGOTテーブルに`free`の実アドレスが入っているはずなので、そこにアクセスしてくれます。

これで全て解決しました！

`objdump`が出来る環境であれば`0x404018`から`free`のオフセット分を引いた値がベースアドレスなので、以下のように書けます
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#define FREE_OFFSET 0xa53e0 // readelfで調べたlibc内のオフセット

int main() {
    // 1. まずfreeを呼んで、GOTに実アドレスをキャッシュさせる
    free(NULL);

    // 2. objdumpの結果からGOTのアドレス（0x404018）を決め打ちで指定
    // この際に最初はgotのアドレスがわからないので、以下の部分は適当に値を入れて一度コンパイルをして、その後objdumpの結果からアドレスを指定する
    void *got_address = (void *)0x404018;

    // 3. GOTの中身（freeの実アドレス）を取り出す
    // 中身は64bitアドレスなので、uintptr_t（8バイト）で読み出す
    uintptr_t real_free_addr = *(uintptr_t *)got_address;

    // 4. ベースアドレスを計算
    uintptr_t libc_base = real_free_addr - FREE_OFFSET;

    printf("Libc Base: 0x%lx\n", libc_base);
    return 0;
}
```

しかし、わざわざ一度コンパイルを挟んで値を入れ直すのは面倒なので一度の実行でアドレス計算まで行わせるようなコードにしましょう

先ほどの`objdump`をバイト単位で分解すると以下のようになります
```shell
401030:       ff 25 e2 2f 00 00       jmp    *0x2fe2(%rip)        # 404018 <free@GLIBC_2.2.5>

バイト位置    値     C言語での書き方
free + 0    ff                         # jmp命令の1バイト目
free + 1    25
free + 2    e2     (void *)free + 2    # リトルエンディアンの1バイト目
free + 3    2f
free + 4    00
free + 5    00                         # リトルエンディアンの4バイト目
free + 6    68     (void *)free + 6    # 次の命令の開始位置
```

`objdump`の結果からもわかるように、機械語の命令では`free`のアドレスから2バイト分先の`e2 2f 00 00`というオフセットの値と、次の命令のアドレスを足したものがGOTテーブルのfreeの入っているアドレスとなっています

なのでコード内でそれらを自動的に計算してくれるようにすれば、万事解決です


まずはRIP(次の命令のアドレス)から求めていきましょう
これは簡単で、上でも書いたように、`free`のアドレスから6バイト分先の部分が次の命令の先頭になっています。よって以下のように書けます

```c
(void *)free + 6
```

> なぜ(void *)?
>
> これはアドレスを1バイトずつ扱うためです。通常関数ポインタ(`free`)に対して、サイズが未定義なので足し算をすることができません。例えば`int *p`に対して`p + 1`をすると、メモリ上では4バイト進んでしまいます（intは4バイトで確保されるため）
> しかし、今回は6バイトや2バイト進める、という操作を行いたいです。そのため`(void *)`にキャストすることでコンパイラが1バイト単位のメモリとして扱ってくれます

次にオフセットの計算をします
今回欲しいのは`free`のアドレスから2バイト進んだ`e2`からの4バイトです。よって4バイト分のアドレスを抜き取るために`int`型にキャストします。こうすることで、`e2 2f 00 00`を取得することができます（`int`にキャストせずにlong(8バイト)などにキャストすると、それ以降の`68 ...`のデータも混入してしまいます）

```c
*(int *)((void *)free + 2)
```

そして、最終的に欲しいのは**GOTの中に入っている実アドレス**です。
64ビットCPUにおいて、メモリアドレスのサイズは64ビット（8バイト）であり、`uintptr_t`はその環境におけるアドレスをそのまま入れられるサイズの整数型であり、64ビット環境では8バイトになります
よって、指定したアドレス(GOTアドレス)から8バイト分（実アドレスの長さすべて）を読み取ることができます

```c
*(uintptr_t *)((void *)free + 6 + *(int *)((void *)free + 2))
```

キャストで型を決めて、`*`でアドレスを取得しています。
RIPの場合はアドレスの中にある値ではなく、アドレスの値のみを知りたいので`*`を使用する必要がありません


これが`free`が呼ばれた際の`GOTテーブル`に書かれているアドレスです。ここから`readelf`で取得したオフセット分を引けばベースアドレスを無事入手できました

#### あとは足すだけ

ベースアドレスが分かればもうすべて終わっており、最初に`readelf`をしてわかったマシン固有の`glibc`の中の呼びたい関数のオフセットを足せば良いです

以下が最終的なコードです。最初に読んだ時全く分からなくても、今ならすべて理解できると思います
`hacked_system`は自分で定義した関数ポインタです。自分で定義したとはいえ、実際の中身は本物の`system`関数なので、引数の型などは`man`などを参照して揃えるようにしましょう

```c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// 以下の値は、上記のファイルで使用したreadelfコマンドを手元で実行して出てきたoffsetの一覧から
// grepなどをして system, free の値を入れる。16進数なので頭に0xを付ける
#define SYSTEM_OFFSET 0x50d70
#define FREE_OFFSET 0xa53e0

int main(int argc, char **argv) {
  if (argc != 2) {
    return 1;
  }

  free(NULL);
  uintptr_t libc_base = 
    *(uintptr_t *)((void *)free + 6 + *(int *)((void *)free + 2)) - FREE_OFFSET;
  
  int (*hacked_system)(const char *) = (void *)(libc_base + SYSTEM_OFFSET);

  return hacked_system(argv[1]);
}

```

最初は`free(NULL)`の意味が全く分からないと思いますが、PLTやGOTを理解した後だと、これがどれだけ重要か分かると思います。(なるべく外部に影響の少ない関数であれば`free`でなくても何でも構いません)
最初に`free`を一度呼ばないと、リンカによってアドレス解決がされず、GOTの中身にはPLTの次の命令のアドレスが入っているだけなので、よく分からない値にアクセスして`segmentation fault`になってしまいます

最後に`nm`で実際に確認してみましょう

```shell
$ nm -D a.out 
                 U free@GLIBC_2.2.5
                 w gmon_start
                 U __libc_start_main@GLIBC_2.34
```

非常に綺麗ですね。`free(NULL)`で呼んだ`free`のみが外部関数として定義されています。
これでnmにバレずに外部関数をひたすら呼び出すことができます！！

# おまけ

オフセットを求めるにはローカルで`readelf`などを使えばいいのですが、自分の環境ではない環境のオフセットを求めたい時に
